{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vrc import *\nfrom vexcode_vrc.events import get_Task_func\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\narm_motor = Motor(\"ArmMotor\", 3)\nrotation = Rotation(\"Rotation\", 7)\nintake_motor = Motor(\"IntakeMotor\", 8)\noptical = Optical(\"Optical\", 11)\ngps = GPS(\"GPS\", 20)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n#region helper functions\ndef format_angle(a):\n    sign = 1\n    if a < 0:\n        sign = -1\n    else: \n        sign = 1\n    positive_a = abs(a)\n\n    mod = positive_a % 360\n\n    if mod <= 180:\n        return sign * mod\n    else:\n        return sign * (mod - 360)\n#endregion helper functions\n\n#region classes\nclass Coord:\n    def __init__(self, x, y, theta=0):\n        self.x = x\n        self.y = y\n        self.theta = theta\n\nclass Chassis:\n    __instance__ = None\n\n    def __init__(self):\n        if Chassis.__instance__ is None:\n            Chassis.__instance__ = self\n        else:\n            raise Exception(\"You cannot create another Chassis class\")\n    \n    def face_angle(self, angle):\n        drivetrain.set_turn_velocity(100, PERCENT)\n        position = Coord(gps.x_position(MM), gps.y_position(MM), gps.heading())\n\n        target_angle = format_angle(angle - position.theta)\n        drivetrain.turn_for(RIGHT, target_angle, DEGREES)\n\n    def face_coord(self, x, y, aiming, offset):\n        drivetrain.set_turn_velocity(100, PERCENT)\n        position = Coord(gps.x_position(MM), gps.y_position(MM), gps.heading())\n\n        dx = x - position.x\n        dy = y - position.y\n\n        target_angle = 90 - math.atan2(dy, dx) * 180 / math.pi\n\n        if aiming:\n            # face coord backwards\n            drivetrain.turn_for(RIGHT, float(format_angle(180 + target_angle - position.theta + offset)), DEGREES)\n        else:\n            # face the coord\n            drivetrain.turn_for(RIGHT, float(format_angle(target_angle - position.theta + offset)), DEGREES)\n        \n    def move_to_point(self, x, y):\n        drivetrain.set_drive_velocity(100, PERCENT)\n        position = Coord(gps.x_position(MM), gps.y_position(MM), gps.heading())\n\n        dx = x - position.x\n        dy = y - position.y\n\n        dist = (math.sqrt(dx**2 + dy**2))\n\n        target_angle = 90 - math.atan2(dy, dx) * 180 / math.pi\n\n        drivetrain.turn_for(RIGHT, float(format_angle(target_angle - position.theta)), DEGREES)\n\n        drivetrain.drive_for(FORWARD, dist, MM)\n\n    def move_to_point_backward(self, x, y):\n        drivetrain.set_drive_velocity(100, PERCENT)\n        position = Coord(gps.x_position(MM), gps.y_position(MM), gps.heading())\n\n        dx = x - position.x\n        dy = y - position.y\n\n        dist = (math.sqrt(dx**2 + dy**2))\n\n        target_angle = 90 - math.atan2(dy, dx) * 180 / math.pi\n\n        drivetrain.turn_for(RIGHT, float(format_angle(180 + target_angle - position.theta)), DEGREES)\n\n        drivetrain.drive_for(REVERSE, dist, MM)\n\n    def shoot_while_move_to_point(self, x, y, d):\n        drivetrain.set_drive_velocity(100, PERCENT)\n        position = Coord(gps.x_position(MM), gps.y_position(MM), gps.heading())\n\n        dx = x - position.x\n        dy = y - position.y\n\n        dist = (math.sqrt(dx**2 + dy**2))\n\n        target_angle = 90 - math.atan2(dy, dx) * 180 / math.pi\n\n        drivetrain.turn_for(RIGHT, float(format_angle(target_angle - position.theta)), DEGREES)\n\n        drivetrain.drive_for(FORWARD, d, MM)\n        intake_motor.spin(REVERSE)\n        drivetrain.drive_for(FORWARD, dist-d, MM)\n\n    def shoot_while_move_to_point_backward(self, x, y, d):\n        drivetrain.set_drive_velocity(100, PERCENT)\n        position = Coord(gps.x_position(MM), gps.y_position(MM), gps.heading())\n\n        dx = x - position.x\n        dy = y - position.y\n\n        dist = (math.sqrt(dx**2 + dy**2))\n\n        target_angle = 90 - math.atan2(dy, dx) * 180 / math.pi\n\n        drivetrain.turn_for(RIGHT, float(format_angle(180 + target_angle - position.theta)), DEGREES)\n\n        drivetrain.drive_for(REVERSE, d, MM)\n        intake_motor.spin(REVERSE)\n        drivetrain.drive_for(REVERSE, dist-d, MM)\n\n    def intake_ball_at_point(self, x, y):\n        drivetrain.set_drive_velocity(100, PERCENT)\n        position = Coord(gps.x_position(MM), gps.y_position(MM), gps.heading())\n\n        dx = x - position.x\n        dy = y - position.y\n\n        dist = (math.sqrt(dx**2 + dy**2))\n\n        target_angle = 90 - math.atan2(dy, dx) * 180 / math.pi\n\n        drivetrain.turn_for(RIGHT, float(format_angle(target_angle - position.theta)), DEGREES)\n        intake_motor.spin(FORWARD)\n        drivetrain.drive_for(FORWARD, dist - 300, MM)\n        \nclass Intake:\n    __instance__ = None\n\n    def __init__(self):\n        if Intake.__instance__ is None:\n            Intake._instance__ = self\n        else:\n            raise Exception(\"You cannot create another Intake class\")\n\n    def shoot(self, turns):\n        intake_motor.spin_for(REVERSE, turns, TURNS) \n\nclass Robot:\n    __instance__ = None\n\n    def __init__(self):\n        if Robot.__instance__ is None:\n            Robot.__instance__ = self\n            self.chassis = Chassis()\n            self.intake = Intake()\n        else:\n            raise Exception(\"You cannot create another Robot class\")\n\n    @staticmethod\n    def get_instance():\n        if Robot.__instance__ is None:\n            Robot()\n        return Robot.__instance__\n\n    @staticmethod\n    def face_angle(angle):\n        Robot.__instance__.chassis.face_angle(angle)\n    \n    @staticmethod\n    def face_coord(x, y, aiming=False, offset=0):\n        Robot.__instance__.chassis.face_coord(x, y, aiming, offset)\n\n    @staticmethod\n    def move_to_point(x, y):\n        Robot.__instance__.chassis.move_to_point(x, y)\n\n    @staticmethod\n    def move_to_point_backward(x, y):\n        Robot.__instance__.chassis.move_to_point_backward(x, y)\n\n    @staticmethod\n    def shoot_while_move_to_point(x, y, d):\n        Robot.__instance__.chassis.shoot_while_move_to_point(x, y, d)\n\n    @staticmethod\n    def shoot_while_move_to_point_backward(x, y, d):\n        Robot.__instance__.chassis.shoot_while_move_to_point_backward(x, y, d)\n\n    @staticmethod\n    def intake_ball_at_point(x, y):\n        Robot.__instance__.chassis.intake_ball_at_point(x, y)\n\n    @staticmethod\n    def shoot(turns):\n        Robot.__instance__.intake.shoot(turns)\n         \n\n#endregion classes\n\n# Add project code in \"main\"\ndef main():\n    #initalize components\n    robot = Robot.get_instance()\n\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    intake_motor.set_velocity(100, PERCENT)\n    arm_motor.set_velocity(100, PERCENT)\n\n    # Preloads to Blue Goal\n    arm_motor.spin(FORWARD)\n    robot.move_to_point_backward(-250, -1500)\n    robot.move_to_point(-900, -300)\n    robot.shoot_while_move_to_point_backward(-600, -300, 0)\n    drivetrain.drive_for(FORWARD, 100, MM)\n    wait(0.25, SECONDS)\n    \n    # 1st (-600, 0)\n    intake_motor.spin(FORWARD)\n    robot.face_angle(20)\n    wait(0.3, SECONDS)\n    robot.face_angle(90)\n    robot.shoot_while_move_to_point(600, -300, 200)\n\n    # 2nd (-100, 0)\n    robot.intake_ball_at_point(-100, 0)\n    robot.shoot_while_move_to_point(700, 200, 0)\n\n    # 3rd (-125, 600)\n    robot.intake_ball_at_point(-125, 600)\n    robot.shoot_while_move_to_point(700, 0, 100)\n\n    # 4th (-125, -600)\n    robot.intake_ball_at_point(-125, -600)\n    robot.shoot_while_move_to_point(600, -300, 0)\n\n    # 5th (-125, -1100)\n    robot.intake_ball_at_point(-125, -1100)\n    robot.shoot_while_move_to_point(800, -200, 200)\n\n    # 6th (-125, 1100)\n    robot.intake_ball_at_point(-125, 1000)\n    robot.shoot_while_move_to_point(900, 300, 300)\n    \n    # robot.move_to_point(-1100, 1100)\n\n    # LZ 1 (-1600, 1600)\n    for i in range(5):\n        wait(0.05*i, SECONDS)\n        robot.intake_ball_at_point(-1600, 1600)\n        wait(0.2, SECONDS)\n        arm_motor.spin_to_position(0.89, TURNS, wait=False)\n        intake_motor.stop()\n\n        robot.move_to_point_backward(-360, 375-150*i)\n        robot.face_angle(270)\n        wait(0.1, SECONDS)\n\n        robot.shoot(1.2)\n        arm_motor.spin_to_position(3.35, TURNS, wait=False)\n    \n    arm_motor.spin(FORWARD)\n    wait(0.5, SECONDS)\n    robot.face_coord(-1600, 1600)\n    robot.intake_ball_at_point(-1600, 1600)\n    robot.face_coord(-1600, 1600)\n    wait(0.2, SECONDS)\n    intake_motor.spin(REVERSE)\n    robot.face_angle(80)\n    wait(0.4, SECONDS)\n    intake_motor.spin(FORWARD)\n    robot.face_coord(-1600, 1600)\n    wait(0.2, SECONDS)\n\n    robot.move_to_point(500, 1500)\n    robot.move_to_point_backward(900, 1500)\n    intake_motor.spin(REVERSE)\n    robot.move_to_point(1500, 880)\n    robot.face_angle(175)\n    wait(0.4, SECONDS)\n\n    robot.intake_ball_at_point(1600, 1600)\n    robot.face_coord(1600, 1600)\n    wait(0.3, SECONDS)\n    intake_motor.spin(REVERSE)\n    robot.move_to_point(1500, 900)\n    robot.face_angle(180)\n\n    robot.move_to_point_backward(1500, 1000)\n\n# VR threads â€” Do not delete\nvr_thread(main)\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"PG","sdkVersion":"20220726.10.00.00","appVersion":"3.0.5","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"VRC24","robotModel":"vrc24","target":"Physical"}